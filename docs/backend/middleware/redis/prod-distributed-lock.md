# 分布式锁

简单来讲，分布式锁就是满足分布式系统或集群模式下多进程可见并且互斥的锁。

一般情况下，分布式锁需要满足以下几个条件：

- 互斥性：任意一个时刻，锁只能被一个线程（或者进程）持有。
- 高可用：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。
- 高性能：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。

除了上面这三个基本条件之外，一个好的分布式锁还需要满足下面这些条件：

- 非阻塞：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。
- 可重入：一个节点获取了锁之后，还可以再次获取锁。

分布式锁的核心是实现多进程之间互斥，而满足这一点的方式有很多，常见的有三种：

#|互斥|高可用|高性能|安全性
---|---|---|---|---
数据库|利用数据库本身的互斥锁机制（例如 MySQL 的行锁）|好|一般|断开连接，自动释放锁
Redis|利用 `setnx` 这样的互斥命令|好|好|利用锁超时时间，到期释放
Zookeeper|利用节点的唯一性和有序性实现互斥|好|一般|临时节点，断开连接自动释放

本文主要介绍 Redis 分布式锁的实现。

使用 Redis 实现分布式锁，我们主要是用到了 Redis 中的 `SETNX`、`EXPIRE`、`DEL` 等命令。伪代码如下：

```java
// 获取锁
if (setnx('lock', 1)) {
  try {
    // 设置锁超时时间
    expire('lock', 30)
    // 执行业务逻辑
    ...
  } finally {
    // 释放锁
    del('lock')
  }
} else {
  // 获取锁失败，直接返回
  return
}
```
但是呢，这段代码还是有问题的，`setnx` 和 `expire` 两个命令并不是原子的，如果在执行 `setnx` 之后，`expire` 之前，进程崩溃了，那么这个锁就会永远存在，其他进程再也获取不到锁了。为了解决这个办法，我们可以使用 `set` 命令，它可以同时设置多个键值对，而且是原子的。伪代码如下：

```java
// 相当于在 Redis 中执行 set lock 1 EX 10 NX
// 获取锁
if (set('lock', 1, 'NX', 'EX', 30)) {
  try {
    // 执行业务逻辑
    ...
  } finally {
    // 释放锁
    del('lock')
  }
} else {
  // 获取锁失败，直接返回
  return
}
```
当然，我们也可以使用 Lua 脚本来实现分布式锁，这样可以保证原子性。伪代码如下：

- Lua 脚本加锁

```lua
if (redis.call('setnx', KEYS[1], ARGV[1]) == 1) then
    --设置成功返回1，当key不存在或者不能为key设置生存时间时，返回0
    return redis.call('expire', KEYS[1], ARGV[2]);
else
    --没有获取到锁
    return 0;
end
```
- Lua 脚本解锁

```lua
if (redis.call('get', KEYS[1]) == ARGV[1]) then
    --检查锁是否存在，存在则删除
    return redis.call('del', KEYS[1]);
else
    return 0;
end
```

:::tip 提示
`SETNX` 命令是从 Redis 1.0.0 版本开始提供的，`SET` 命令的 EX, PX, NX, XX 参数是从 Redis 2.6.12 版本开始提供的。并且，从 2.6.12 版本开始 `SETNX` 被废弃了，推荐使用 `SET` 命令的 NX 参数。见 [SETNX](https://redis.io/commands/setnx/)。

在 Java 中，由于 Redis 客户端版本的问题，部分客户端 API 可能没有提供 `SET` 命令的 EX, PX, NX, XX 参数，这时候我们可以使用 `EVAL` 命令来执行 Lua 脚本，或者使用 `JedisCluster` 来实现分布式锁。
:::
