# 简介

:::tip 参考
[Apache Kafka](https://kafka.apache.org/)
:::

## Kafka 传统定义

一个分布式的发布-订阅消息队列，主要应用于大数据领域，如日志收集、监控、数据采集等。

## Kafka 最新定义

一个开源的分布式事件流平台。

## 消息队列模式

:::tip 参考
[详解Kafka消息队列的两种模式](https://blog.csdn.net/qq_43437122/article/details/108391145)
:::

为什么要提到消息队列的模式呢？了解了这些模式，我们就能更好的理解 Kafka 的设计思想。这些模式不仅仅对 kafka 适用，对其它消息队列也适用。

**点对点模式**  

生产者往某个队列里面发送消息，一个队列可以存储多个生产者的消息，一个队列也可以有多个消费者，但是消费者之间是竞争关系，即每条消息只能被一个消费者消费，消息被消费后，该消息就会被从队列中移除。

`RabbitMQ` 采用点对点模式。

**发布订阅模式**

生产者往某个 topic（主题，可以理解为队列）发送消息，一个主题可以有多个生产者，一个主题也可以有多个消费者，消息被发送到主题后，所有订阅了该主题的消费者都会收到这条消息。并且，消息被消费后，不会立即从 topic 中移除（不同消息队列的移除策略不同）。

为了提高并发度，往往发布/订阅模式还会引入队列或者分区的概念。即消息是发往一个主题下的某个队列或者某个分区中。RocketMQ 中叫队列，Kafka 叫分区，本质一样。例如某个主题下有 5 个队列，那么这个主题的并发度就提高为 5 ，同时可以有 5 个消费者并行消费该主题的消息。

`RocketMQ` 和 `Kafka` 采用发布/订阅模式。

**推拉模式**  

:::tip 提示
这是作为发布/订阅模式的补充，参考 [MQ 队列模式以及推拉模型概念详解](https://juejin.cn/post/7111741311920635912)
:::

一般而言，我们在谈论推拉模式的时候指的是 Comsumer 和 Broker 之间的交互。默认认为 Producer 与 Broker 之间就是推的方式，即 Producer 将消息推送给 Broker，反之是 Broker 主动去拉取消息。

- **推模式**

  推模式指的是消息从 Broker 推向 Consumer，即 Consumer 被动的接收消息，由 Broker 来主导消息的发送。
  
  推模式的优点是消息实时性高，Broker 接受完消息之后可以立马推送给 Consumer。对于消费者使用来说更简单，简单啊就等着，反正有消息来了就会推过来。
  
  推模式的缺点是推送速率难以适应消费速率，当生产者往 Broker 发送消息的速率大于消费者消费消息的速率时，随着时间的增长，消费者那边可能就“爆仓”了。不同的消费者的消费速率还不一样，身为 Broker 很难平衡每个消费者的推送速率，增加了 Broker 自身的复杂度。推模式难以根据消费者的状态控制推送速率，适用于消息量不大、消费能力强，要求实时性高的场景。

- **拉模式**

  拉模式指的是 Consumer 主动向 Broker 请求拉取消息，即 Broker 被动的发送消息给 Consumer。

  拉模式的优点是消费者可以根据自身的情况来发起拉取消息的请求。Broker 就相对轻松了，它只管保存生产者发来的消息，参考消费者请求的信息来决定缓存多少消息之后批量发送。

  拉模式的缺点也很明显，由于需要消费者定期拉取，所以消费有延迟。此外还会造成消息忙请求，忙请求就是比如消息隔了几个小时才有，那么在几个小时之内消费者的请求都是无效的，在做无用功。

- **长轮询**

  RocketMQ 和 Kafka 都是利用“长轮询”来实现拉模式，用以平衡 Pull/Push 模型各自的缺点。具体的做法都是通过消费者等待消息，当有消息的时候 Broker 会直接返回消息，如果没有消息都会采取延迟处理的策略，并且为了保证消息的及时性，在对应队列或者分区有新消息到来的时候都会提醒消息来了，及时返回消息。一句话说就是消费者和 Broker 相互配合，拉取消息请求不满足条件的时候 hold 住，避免了多次频繁的拉取动作，当消息一到就提醒返回。 
